#+TITLE: Rxjs 复杂交互架构实践
#+DATE: 2019-08-04 17:26:54
#+AUTHOR: 陳放為

* 错误的架构
在某个项目中，我们实现了一个类似 Trelo 的功能，一个看板，里面有很多列，列里面有很多卡片。嗯，实际情况比这个复杂的多，例如一个板下面有很多个“泳道”，每个泳道哦就是一个小小的看板，还要支持拖拽和权限。

** 单一数据源的错误
当然故事从一个错误的组件数据流架构说起

因为业务原因，后端服务只能给前端一些比较原始的数据，所以需要在前端进行数据的加工，当时有考虑到采用 *单一数据源* 的原则，采用了一种集合数据的方案，也就是把数据都存到 store 里面，在 *容器组件* 里面进行计算，这里面的计算包括顺序，归类，统计之类的计算，计算量不多不少。

当时前端采用了一种错误的方案：对于这个卡片列来说，我们认为在容器组件中告诉他低下有多少个 Item，每个 Item 的 ID 就行了，剩下的由卡片列去查询 store。

#+BEGIN_QUOTE
当时之所以会采用这种方案，一方面是我们想避免类似 =Redux= 架构的优化，把数据从很上层一直往下传，这样的架构往往会令人在 =props= 中迷失；另一方面是当时错误的理解了“单一数据源”这个理念，认为从组件里去观察 store，更能贴近变化，事实上这是一个错误的实现。
#+END_QUOTE

[[image-url:./Rxjs 复杂交互架构实践/4a3f53592533c70e31be587584d1b131]]

** 为什么是一个错误的实现

*** 非单一数据流
非单一的数据流，因为 [卡片板] -> [泳道] -> [卡片列] -> [卡片] 这个数据流向中，是一个单一的流向。我们从［卡片板］中算好了每个卡片列的数据，只把 card id 的数组传进了［卡片列]，然后再次通过访问单一 state 来取得卡片这个实体的数据，虽然是从单一的 state 来取得卡片数据这一点很单一，但是实际上并不是，因为通过筛选而得出的 card id 列表，也是另外一个来源，试想一个场景，如果要把卡片删除掉，id 列表的变化和 card state 变化也同时进行的，这其中有竞争的关系

*** 有重复的计算
按照上面的实现，我们在卡片这个实体计算中，是带了很多重复的计算的：
1. 从




[[image-url:./Rxjs 复杂交互架构实践/065a107326156f8f166ad4625782b9d4]]


