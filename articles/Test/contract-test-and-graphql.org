
#+TITLE:  前端契约测试与GraphQL契约模式实践
#+AUTHOR: 陳放為

* 前端契约测试

** 引子：
    我曾经在某个项目里呆过，当时我们只有单元测试，还有几套 e2e 测试，不过因为业务进度的压力，只覆盖了几个基本的场景。
    
    不过在当时的开发模式下，前端经历过几次比较严重的 bug，而原因都是因为 API 接口的问题，似乎可以分析一下原因。


    *为什么会有严重的 bug：*

    其实是因为后端同学因为重构或者新增的业务功能修改了接口，但是没有告诉前端，原因是当时觉得改动很小，就没有告诉前端，也有可能是忘了，anyway，而前端用到这个接口的地方又比较隐蔽，毕竟是已经做了很久的系统，也没有故事卡迭代涉及那块，所以也没有测试人员力量覆盖，最终导致了 bug。


    可能会有其他非技术手段来防止再次发生，例如做技术任务一定要建卡，改了一定要通知前端之类的约束。
    
    只是有人的地方就有江湖，是人写的代码总会有 bug，没有全面 e2e 测试的情况下，后端的接口和前端始终存在一道隔膜，只能通过人工测试覆盖。

    而 e2e 的测试成本太高（请见测试金字塔理论），我们基于进度的压力也写不了全面的 e2e。

*想法💡：*

    我们现在的开发模式是前后端分离开发，用的共享契约作为接口定义，而后端已经是实现了契约测试了，也就是说，后端的实现是按照契约的来的。

    那么，只要前端对契约进行了测试，那么后端修改了契约，那么前端的测试就能知道，去响应这个变化，防止后端的变化多前端功能破坏。

*于是乎，我们在另一个项目中探索了一下在 GraphQL 契约模式下的前端契约测试实践*

** 前后端共享契约

在讲前端契约测试之前其实可以看看什么是共享契约：

在项目里，我们对契约的实践演化成“共享契约”。

关于共享契约可以看一下 MacDao 写的《[[共享契约]]》，共享契约有几个特点:

1. 它和基于Schema的几个工具一样，需要定义契约文件。契约文件独立于前后端代码，前后端开发人员都可以对其制定和修改，契约是前后端共享的，所以称之为共享契约。
2. 共享契约模式的契约也是基于Example的，所以可以运行成Mock Server。
3. 前端可以使用Mock Server编写契约测试。
4. 由于是基于Example的，后端测试的问题也解决了。

总的来说，共享契约就是现在很多项目都在实践的：前端用契约来跑 mock server，可以让前后端的开发工作不互相依赖。


** 前端契约测试

*** 为什么要前端契约测试

由前文所述：

- 接口的变动把控
- 在发生契约变化时，提供一种可立即被服务端和消费端发现的方式。

*** 我们是怎么做的

在实践中，我们的前端后端没有刻意区分消费者和提供者的概念；我们也没有在前端直接 follow 后端契约测试那一套模式。我们测试了前端 GraphQL 的查询语句是否符合了 GraphQL 契约的定义，如下码：


#+BEGIN_SRC

/* some import */

const contract = getContract('api.json', 'should_do_action');

const subscription = service.doAction().subscribe(/* ignore */);

backend.expectOne(gql`${contract.request.json.query}`).flush(contract.response.json);

#+END_SRC


上面的三行代码，做了这么一件事，读取契约描述文件 =api.json= 并拿到契约定义 json，测试业务代码中的请求方法 =doAction= ，然后我们验证这个方法 GraphQL 查询语句是否和契约定义中的查询语句一致。

#+BEGIN_QUOTE
如果查询语句一致，那么我们得到的数据就是我们想要的
因为在 GraphQL 的查询语句中，我们需要写这样的定义描述，我们想要什么数据都可以直接裁剪，例如下面的查询语句

#+BEGIN_SRC
query Query {
  someThing {
    foo
    bar
  }
}
#+END_SRC

所以这样的测试已经是可以暴露契约的变更了，如果后端实现变了，这里就会测试失败

#+END_QUOTE

*** 为什么这个契约测试如此的简单？

首先我们没有把这个契约测试想的太复杂和太全面，我们也不想太多工作量在测试契约上，毕竟我们的前后端团队是一个 team，有很多契约的修改，沟通都可以面对面解决；而且契约的修改在项目前期也显得频繁，没有必要花费过多实践在这上面。

其外这种契约测试的模式还在实践中，我们通过契约这种“媒介”，把这种前端契约测试*当作*了一种低成本的集成测试，这样的契约测试在两三个月的敏捷交付中确实能发挥了作用：及时发现了契约在非预期内的变化等等。

*** 契约数据 UI 测试

契约，作为前后端开发的媒介，后端对于契约，其实关注在输入输出，后端有很好测试模式可以测试接口的输入输出。

但是前端的价值其实绝大部分在视觉输出，没有 UI 的输出，前端不管数据处理的多完美，都是没有意义的，但是在 *单元测试* 中很多都是 mock 数据作为输入，然后渲染，在单元测试中，并没有对接契约，导致很多时候，契约修改了，修改代码的时候，忘记了修改测试，导致那个单元测试成了一个死的单元测试，没有意义的存活着，甚至一直没有人会发现。


#+BEGIN_QUOTE
注：
1. 我们先不谈 E2E 测试，毕竟不是一个概念。
2. 我们也先不谈前端 TDD，关注与这种现象，毕竟 TDD 也不会完全杜绝这种情况
3. 我们也先不谈是不是单元测试没有写好，毕竟不是每个单元测试都能写得那么完美和高大上
#+END_QUOTE

那么，我们在组件的测试中，也使用了契约的数据作为输入，先上码：

#+BEGIN_SRC
const contract = getContract('api.json', 'should_do_action');

const q$ = cold('--x|', { x: contract.response.json as SomeModel });
const doActionService = fixture.debugElement.injector.get(DoActionService);
spyOn(doActionService, 'doAction').and.returnValue(q$);

component.ionViewDidLoad();

getTestScheduler().flush();
fixture.detectChanges();

const element: HTMLElement = fixture.nativeElement;

const fooDom = element.querySelector('.foo');
const barDom = element.querySelector('.bar');

expect(fooDom.textContent).toEqual('Hello');
expect(barDom.textContent).toEqual('World');
#+END_SRC

如上码：这个组件在测试的时候，用的是活的数据，来自于契约的数据，而不是在测试里面重新 mock 的数据，如果契约更新了，某些数据不符合前端的要求了，那么这个测试就会失败，从而暴露问题。


#+BEGIN_QUOTE
注：这个组件测试和上面的契约测试case为什么没有在一起写，或者所为什么没有放在一起利用那个方法来获取数据，是因为我们的代码严格把 UI 组件和业务逻辑隔离开来，在测试中也想让测试更单元，让两块代码分开测试。

#+END_QUOTE


* GraphQL 契约模式

在上面说的，我们用了一个比较新的技术: GraphQL

#+BEGIN_QUOTE
GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。
#+END_QUOTE

我们用 GraphQL 主要想解决项目里出现的复杂网络请求的情况，通过 GraphQL 确实能减少一些请求的数量，并且可以实现由客户端自由获取我们想要的数据。


# 这个项目在很紧张的迭代着，业务的修改，接口修改实现和重构都非常频繁的进行着，这对前端造成了一定的困扰，因为单元测试并不能暴露出这些接口的异常，而这些接口的改动同样频繁的破坏着客户端已经实现的功能。

在 GraphQL 这个技术选型上，我们还花了一些时间来讨论，我们用了 GraphQL ？还需要契约吗？毕竟 GraphQL 在后端的 schema 里已经定义好了各种数据模型，并且数据也可以由前端自由组合获取，如果定义了契约，把前端的请求囿于契约定义中，或许失去了 GraphQL 的意义。


最后我们还是决定书写契约定义文件。

原因有下： 
1. 前后端的测试中还有开发中还是需要 mock server，需要 example
2. 基于敏捷故事卡的开发，契约应该描述故事卡的业务和数据，schema 里面的数据太过抽象，显得难以理解。
3. 至于前端想自由请求数据，这个是否会大大增加契约的冗余度和工作量，我们暂时不考虑，我们实践先行，以后可以优化。
4. example 给 BFF 层测试（还有以后的前端契约测试）

最后，我们的契约文件长下面的模样

#+BEGIN_SRC
{
    "description": "should_query_foos",
    "request": {
      "method": "POST",
      "uri": "/graphql",
      "headers": {
        "Authorization": "Basic token=="
      },
      "json": {
        "query": "query Query() { foo() { id name }}"
      }
    },
    "response": {
      "status": 200,
      "json": {
        "data": {
          "foo": [
            {
              "id": "123",
              "name": "bar"
            }
          ]
        }
      }
    }
  }
#+END_SRC


** mock server

前端把上面的契约作为我们本地开发端的 mock server，根据描述语句和变量匹配，返回契约定义的 HTTP 响应

#+BEGIN_QUOTE
这个项目到现在三个月的时间里，GraphQL 的这种契约模式还算可以，并没有出现因为自由裁剪组合的 GraphQL 查询出现令契约冗余的情况 
#+END_QUOTE

* 前端契约测试的一些思考

** 放在单元测试里面还是新开一套测试?


#+BEGIN_SRC

/* some import */

const contract = getContract('api.json', 'should_do_action');

const subscription = service.doAction().subscribe(/* ignore */);

backend.expectOne(gql`${contract.request.json.query}`).flush(contract.response.json);

#+END_SRC

在这个测试 case 里面，由于契约文件是会变的，虽然可能不会变的很频繁，但是从某一个方面讲，如果这个测试 case 放到单元测试里，整个单元测试可能变得不会太单元，毕竟，如果契约更新了的话，测试会挂掉。

当然，从另一个方面讲，世界上没有完全单元的测试，毕竟过于单元，则会减弱测试暴露错误和问题的能力。

所以，前端契约测试放在哪里取决于具体的情况和对测试的定义，因为契约就是约定，后端是根据契约实现接口功能的，如果你认为如果这套测试挂了就是功能跑不过，在 CI 挂了就是破坏了系统的功能，那么在单元测试里面也未尝不可。

这也跟契约版本化有关系，如果契约文件在单元测试里面也是做了版本化的，那么只要契约版本没有更新，那么放在单元测试里面也是可以，因为只要你不更新契约的版本，就不会发生破坏单元测试的情况；如果契约变了单元测试又挂了，那么就是证明确实破坏了功能，那么你有什么理由不修呢？

** 消费者驱动？
前端有了契约测试，在前后端分离团队必然会导致一个问题，就是这个契约究竟由前端还是后端驱动的问题。

如果后端要修改某个功能，那他必然会去修改契约，然后契约变化了，必然会导致前端测试挂彩，那么问题来了，如果前端没有人力资源去支持后端这个功能修改的话，那么前端的测试就会挂掉。

如果团队是消费者驱动的模式，只有前端才能去驱动契约修改（这要求消费者一定要比提供者做的快，反之亦然），那么这个问题其实不会出现。

在实际上很多情况都不会特别完美，消费者驱动或者提供者驱动的界限不会特别清晰，也有很多种解决方案，例如契约变化了双方都快速响应，或者 ignore 掉测试，或者做出兼容方案等等，这个问题还是要根据具体情况进行修订或者妥协。


-----

参考:
# [[共享契约]]
[[https://martinfowler.com/articles/consumerDrivenContracts.html]]

