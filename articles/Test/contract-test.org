#+TITLE: 前端契约测试实践
#+AUTHOR: 陈灿豪

* 前端契约测试实践

** 契约测试
*** 引子：
    曾经在招行的招赢通，我们只有单元测试，还有几套 e2e 测试，但是都因为业务进度的压力，只覆盖了几个基本的场景。
    
    本来大家觉得也什么，但是前端经历过几次重大 bug 之后，我似乎看透了什么。

    [[./contract-test/eye.jpg]]

    原因：

    后端修改了接口，但是没有通知前端，问起原因是当时觉得改动很小，就没有通知前端，而前端用到这个接口的地方又比较偏远，也没有故事卡迭代涉及那块，所以也没有测试人员力量覆盖，最终导致了 bug。

    虽然可能会有其他办法来防止再次发生，例如做技术任务一定要建卡，改了一定要通知前端，但是有人的地方就有江湖，是人写的代码总会有 bug，没有 100% 的 e2e 测试的情况下，后端的接口和前端始终存在一道隔膜，是一道痛。

    而 e2e 的测试成本太高（请见测试金字塔理论），我们基于进度的压力也写不了全面的 e2e。
    
    [[./contract-test/naohuo.jpg]]

    但是：

    当时前后端是契约驱动开发，而后端已经是实现了契约测试了，也就是说，后端的实现是按照契约的来的，那么，只要前端对契约进行了检查，那么前后端的“隔膜”就不会那么明显了，后端修改了契约，那么前端就能知道，去响应这个变化，防止后端的变化多前端功能破坏。


** 前端契约测试 
在招行智能保险项目，因为是深圳成都两地开发，也是用契约分离前后端，并跟前后端共享契约，和祁兮讨论了一下，我想祁兮的根据《共享契约》一文中的前端契约测试理念来尝试一下前端的契约测试。

*** 目的
    根据《共享契约》中的理念，支持前端契约测试，针对项目具体的情况，列了前端契约测试要解决的问题和不希望产生的问题：
**** 希望解决的问题
     1. 从前端测试的角度感知 api 变化
     2. 防止 api 变化对前端功能的破坏
**** 不希望产生的问题
     1. 不希望前端契约测试成为一个对 api 的检验工具
     2. 不希望前端契约测试产生很多的 effort

*** 前后端共享契约
在招赢通项目里，我们对契约的实践演化成“共享契约”，(关于共享契约可以看一下祁兮写的《[[http://qixi.com][共享契约]]》)。

共享契约有几个特点:

1. 它和基于Schema的几个工具一样，需要定义契约文件。契约文件独立于前后端代码，前后端开发人员都可以对其制定和修改，契约是前后端共享的，所以称之为共享契约。
2. 共享契约模式的契约也是基于Example的，所以可以运行成Mock Server。
3. 前端可以使用Mock Server编写契约测试。
4. 由于是基于Example的，后端测试的问题也解决了。


总的来说，共享契约就是现在很多项目都在实践的：前端用契约来跑 mock server，可以让前后端


*** 项目实践
**** mock api data
     传统的前端 api 测试的流程是，运行被测试代码，然后通过测试工具拦截发出的 http 请求，然后验证是否 url 和 body 等是否正确，最后返回在测试代码里面写死的返回数据，flush api 请求，验证业务代码的正确性。
     来着项目成员代码事例: (不喜勿喷）

     [[./contract-test/wanle.JPG]]

     #+BEGIN_SRC typescript
  it(
    'getCompanysSelectOption',
    inject(
      [InsureCompanyService, HttpTestingController],
      (service: InsureCompanyService, httpMock: HttpTestingController) => {
        let selectOption;

        getContractResponse('company/companies/get ybt companies.json').then(response => {
          const subscription = service.getCompanysSelectOption().subscribe(s => {
            selectOption = s;
          });

          const request = httpMock.expectOne('/api/auth/companies');

          assert.hasAllKeys(response[0], ['name', 'code']);

          request.flush(response);
          expect(request.request.method).toEqual('GET');
          expect(selectOption[0]).toEqual({ id: '002', label: '泰康人寿' });

          subscription.unsubscribe();
        });
        httpMock.verify();
        }
      )
    );
#+END_SRC
上面代码中，getContractResponse 这个函数通过契约的路径获取契约生成出来的 response data

而 InsureCompanyService 这个 Angular service 是一个保险公司的 service，它有一个 public 方法叫 getCompanysSelectOption 来获取保险公司，然后组装成 select options

我们很正常的用 http requet mock 这种套路来 mock 请求，然后 flush 数据，验证请求后的运行结果，断言。

以前的做法是在测试代码中硬编码 mock 数据，例如下面一样
#+BEGIN_SRC json
  [
    {
        "code": "002",
        "name": "泰康人寿"
    },
    {
        "code": "101",
        "name": "信诺人寿"
    },
    {
        "code": "102",
        "name": "生命人寿"
    },
    ...
  ]
#+END_SRC

然后 flush 到 requestMock 中

但是以前的做法有几点限制：

1. 这个硬编码其实是前端自己从契约中拷出来的，跟之前的契约没有了联系；
2. 而且有时候契约可能会很长，mock 一大块在测试代码中非常难看；
3. 而且有时候会对一些字端删掉，虽然对测试没有影响，但是有一些地方可能会没有关注到，例如其实是有数据 render 到 html 中的，虽然测试中没有这个字段也能跑过，但是 render 的那部分就相当于忽略了，以后有问题也无法发现;
4. 要是接口修改了，mock 数据可能还是没变，这个测试可能就名存实亡了

[[./contract-test/yo.GIF]]

而前端契约测试的实践会顺便把契约的 response 作为输入 flush 到 httpMock 中，那么上面的几点限制都会得到解决。

当然前端契约测试的重点还是这个:


#+BEGIN_SRC typescript
assert.hasAllKeys(response[0], ['name', 'code']);
#+END_SRC

[[./contract-test/litte.jpg]]

十分简单明了，测试契约中的数组元素是否含有 name 和 code 这两个字端，进行字段检查，如果后端修改了字段名，或者删除，或者增加，都会让这个测试 case 挂掉，从而发现契约的修改。

*** 带来的问题: 消费者驱动
     在前后端分离的开发模式中，后端无疑是产生者，而前端是消费者

     在契约驱动下的前后端分离开发，有了契约才能分离，定义好了契约，然后前端拿着契约开开心心的生成 mock service 去开发了；而后端也拿着契约写契约测试，开发 api 功能。

     但是前端对契约进行了测试了之后，情况就发生了变化：

     假设后端有了新需求，或者对接口进行重构，那么可能就会修改现有的接口，后端一旦把新的契约上传了，前端契约测试就会见红，正常情况下，红了就会去修。但是问题来了，假如后端的新需求或者重构没有空闲的前端资源响应，前端资源都在忙，并且专注于制品，那么情况就是：

     所有前端都在忙，前端 CI 红了，发现不是自己弄挂的，ignore 掉，继续干活

     然后 CI 红了大家都不 push 代码，等着别人来修

     久久未绿，终于忍不住问了一下，反正都没有人弄挂，才发现是契约测试挂了

     [[./contract-test/green.gif]]

     但是契约测试挂了也不是前端弄挂的啊，还是没有人修

     直到热心人士的出现，才会有人修，但是这个修的过程特别费事，因为这不仅仅是契约测试挂了，这是因为需要来了或者后端接口变化，又要去了解需求和上下文，又要写代码去 cover 这些变化，实在是累活，又 block 住了原来的工作。

     于是乎：

     后端为了不影响前端，只能不接新需求，重构接口也必须等到有前端资源配合。

     这就直接造成了消费者驱动模式，当然有些团队可能本来就很 match 消费者模式，但是有些团队就未必。

     “前端必须比后端做得快。”

     这就是消费者驱动的真实写照和要求，通常这是一个很大的挑战和弊端。

     [[./contract-test/sad.jpg]]

*** hasAllKeys or containsAllkeys
    我们在实践中，发现如何断言字段有两种方法

    一种是 hasAllKeys, 这是断言对象中只能存在一些字段，如果有多的字段，则断言错误
    一种是 containesAllKeys, 断言对象中包含一些字段，是所有字段的子集

    我们曾经用 hasAllKeys，但是后端增加了字段，则会导致测试挂彩，后面我们尝试使用 containsAllKeys，那样的话后端增加了字段契约测试不会挂。
    
    但是这样的话会造成契约测试不严谨，然后在消费者驱动的模式下，因为后端的修改都有前端配合，所以最好还是使用 hasAllKeys 来严谨约束

*** 可以做的更好的地方
**** 对类型进行判断
     大家看上面可以发现，其实我们的实践对契约的检查，只是简单的判断了一下字段存在与否，对字段的类型和格式是完全不管的，如果整个套路要做的更好，还是需要把判断类型和格式的功能加上。

**** 运行时解析 typescript type
     因为项目是用 typescript 来写的，所以我们在后端返回的 response 上是有资料类型定义的，只可惜 typescript 的类型只存在于编译期，在测试的运行期没法使用，真是太可惜了。


     当然如果有工具能在运行期调用调用 node，把 ts 的 type 提取出来，做成一个判断对象，那就最好不过了。

[[./contract-test/tech.jpg]]

-----
参考:
[[共享契约]]
[[https://martinfowler.com/articles/consumerDrivenContracts.html]]

