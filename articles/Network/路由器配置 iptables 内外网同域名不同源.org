#+TITLE: 路由器配置 iptables 内外网同域名不同源
#+AUTHOR:


* 为了解决什么问题

我在家里路由器的网络环境中搭建了一套 seafile，但是没有公网 ip，也不能 DDNS，所以我用内网穿透把这个服务穿透到了我的一台阿里云 ECS 上，但是国内的 ECS 大家都懂的，水管非常小，我的只有 3M，在外面用其实也不慢，但是在家里用的话，还是这么慢，感觉有点不爽。


#+BEGIN_QUOTE
这里不得不吐槽一下 seafile，这一点跟 nextcloud 的设计还是差了一大截，seafile 需要设置服务域名，上传下载直接要用调用一个设置好的域名或者 ip 的 seahub 服务。而 nextcloud 允许配置多个可访问域名。
#+END_QUOTE


于是，我就想在路由器上配置 iptables 和 route 规则，在我家环境下，访问 seafile.domain.com 的外网地址的时候，直接转发到内网的 seafile 服务上，不用绕去阿里云上。


* hosts & dns
其实如果把 docker 网络都桥接出去的话，其实只需要自定义的 dns 就可以了，甚至说在本机上修改 /etc/hosts 就可以了，但是因为我的 seafile 搭建在了铁威马上的 nas 上，而那个系统的 linux 没有安装 brctrl，这个桥接工具包，上面只有 rpm，安装 brctrl 这种层层有依赖的工具包非常麻烦，我就打消了这个念头。

* iptables 设置
既然不想用 host 解决问题，那么只能用 iptables 把 ip 和 port 都 forward 转发一下了，理论上来说，iptables 是可行的，就是把 ip1:port1 的流量全部转发到 ip2:port2 上


google 了一下，发现下面这篇文章讲的非常系统


[[http://jensd.be/343/linux/forward-a-tcp-port-to-another-ip-or-port-using-nat-with-iptables]]

以下是文章里的用图


[[image-url:./路由器配置 iptables 内外网同域名不同源/c175e644f5fd33497f00ed8463cd99ed]]

[[image-url:./路由器配置 iptables 内外网同域名不同源/8a825f251d16ea8c3b005e2ad08d0888]]

文章上讲的理论跟我想的差不多

这要用到 iptables 的 nat 表，大概意思就是跟我们的 nat 技术一样，只不过这个 nat 表在我们这里只用在了内网

nat 技术讲子网的 ip 全部用一个 ip 转发，在内网的 ip 要跟外面的通信，其实是发到了出口的公用 ip 上，那么网络包中就要带着源头 ip 的信息和目标 ip 的信息，由网关来记住这个信息，因为这其实就是进出的两套规则，那么对应在 iptables 上就是 =PREROUTING= 和 =POSTROUTING= 这两套规则

根据文章上的教程

[[image-url:./路由器配置 iptables 内外网同域名不同源/fa1bebb606dfd16fc3bd37c2334643a0]]


#+BEGIN_SRC bash
[jensd@cen ~]$ sudo iptables -t nat -A PREROUTING -p tcp --dport 9999 -j DNAT --to-destination 192.168.202.105:80
[jensd@cen ~]$ sudo iptables -t nat -A POSTROUTING -p tcp -d 192.168.202.105 --dport 80 -j SNAT --to-source 192.168.202.103
[jensd@cen ~]$ sudo iptables -t nat -L -n
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:9999 to:192.168.202.105:80
 
Chain INPUT (policy ACCEPT)
target     prot opt source               destination
 
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination
 
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination
SNAT       tcp  --  0.0.0.0/0            192.168.202.105      tcp dpt:80 to:192.168.2
#+END_SRC

在我这里是

seafile.domain.xyz 这个域名的外网 ip 是 23.108.69.217(虚构)，而端口是443, 走的https 加密


#+BEGIN_QUOTE
服务上的 https 是用 Let's Encrypt 生成的，用 nginx 启动了 https 服务，反向代理到服务器上 127.0.0.1:xxxx 上内网穿透的端口上

为了跟外网保持一致，我在服务器上把 https 证书下载了下来，启动了另一个 docker nginx，运行了跟服务上一样的 https 服务
#+END_QUOTE

而 seafile 代理服务在我家里内网的 ip 是 192.168.50.2，https 端口是 8094

那么要转化的ip 和 端口就是  23.108.69.217(虚构) : 443 =>  192.168.50.2 : 8094

于是我写了两条命令，ssh 到路由器上执行


#+BEGIN_QUOTE
我的路由器是华硕的 AC86U，已经打开了 ip 转发的功能，如果是其它机型，可能还需要其它额外的操作，例如，ssh 进去等等
#+END_QUOTE


#+BEGIN_SRC bash
iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to-destination 192.168.50.2:8094

iptables -t nat -A POSTROUTING -p tcp -d  192.168.50.2 --dport 8094 -j SNAT --to-source 23.108.69.217
#+END_SRC

执行完了之后，在 wifi 网络下打开 seafile.domain.com，证实了这就是我在内网搭建的服务，速度飞快

但是。。。

当我准备完成工作刷一下抖音的时候，发现抖音打不开了，然后发现其它网站都打不开了，报的证书错误，我瞬间就明白发生了什么事，肯定是刚才在路由器上的操作导致的。

而表现也十分明显，就是所有的 443 端口流量都转发到了我内网的 seafile 服务上。

我仔细查看了一下刚才的两个命令，发现有一点不对劲，上面一条命令只有一个 ip，那么我猜测是目标 ip 没有写，虽然我也不懂这个命令，但是我学着下面的命令加了一个参数 -d 23.108.69.217

也就是


#+BEGIN_SRC bash
iptables -t nat -A PREROUTING -p tcp -d 23.108.69.217 --dport 443 -j DNAT --to-destination 192.168.50.2:8094

iptables -t nat -A POSTROUTING -p tcp -d  192.168.50.2 --dport 8094 -j SNAT --to-source 23.108.69.217
#+END_SRC


然后把之前的删掉，重新运行两个命令，大功告成


## 参考文章


[[Four ways to connect a docker container to a local network][http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/]]


