#+TITLE: Ionic2 + Angular2 实战
#+AUTHOR: 陳放為

Angular2 出来已经一段时间了，现在做的一个公司项目是用 Ionic1，呵呵，其实还是蛮坑的，所以 Angular2 一到 beta 阶段，我就想跃跃欲试，所以做了一个小项目练练手。

做了一个 hacker news 的客户端。

Hacker News是Y Combinator旗下的一个新闻频道，属于digg类产品，挺受欢迎的，我偶尔都会上去看看有什么新闻，基本上与技术有关的都会涉及到。

比较简单的一个项目，代码放在这里。 

[[https://github.com/A-Horse/hack-newer][https://github.com/A-Horse/hack-newer]]

使用 ionic2 不用关心 angular2 的什么配置，部署，ionic2 都帮你把这些琐事做好了，你只需要了解 angular2 的一些基本概念，我之前也研究过 react native， typescript 就我不用学了，很快上手 (针对对 angular1 熟悉的同学来讲，至于之前没有用过 angular1，建议还是深入了解一下 angular 的设计思想。)

** angular 2
下面来简单介绍一下 angular2 的一些我觉得比较特别的特点。

*** 更易于推论
在当前版本的 Angular 中，我们有时不得已对应特定的使用场景推论框架内部构建，比如必须推论应用事件初始化和摘要循环：
在 Angular 1 中没有摘要循环结束事件 (查看原因)，因为这种事件可能会促发更多的变化，以至于使摘要循环持续下去
我们必须推论何时调用 $scope.apply 或 $cope.digest，而这并不总是容易的
有时我们必须调用 $timeoutto让Angular 结束摘要循环，当 DOM 稳定时再做一些操作
为了使 Angular 2 更易于推论，一个目标是创建更多开箱即用的透明内部构建。开始之前，让我们看看 Angular 1 的绑定机制是如何实现的，然后如何使它更透明。

/对与 angular1 来说，这个是最致命的，开发过 angular1 的人都会了解到，当出现一个红色的报错，但是你缺没有办法从控制台定位到哪里错，是多么的痛苦，这就是 angular1 循环事件恶心之处/

*** Zones
angular 1一直同简单 Javascript 对象进行同步，尽管这样可以工作，但是这使得有时难以进行推论：
- 不清楚哪些监视器会运行，什么顺序，多少次
- 模型更新顺序难以推论和预期
- 摘要循环多次运行导致时间消耗
Angular 团队制定 Angular 2 开发方向时，其中一点是提取 Angular 代码中的异步交互点补丁机制，以便可以重用它。

这些重构的结果就是 Zone.js，它类似于 Java 中的 thread-local 上下文。
他可以用于很多场景，比如可以允许框架生成更长的跨越多个 JavaScript VM 的堆栈跟踪信息。

Angular 2 使用 zones 机制使摘要循环不再被需要。简单的非 Angular 指定代码可以透明地激发一个Angular 2 摘要，如下是由一个 zone 中的组件激发的示例：

#+begin_src javascript
element.addEventListener('keyup', function () {  
  console.log('Key pressed.');
});
});
#+end_src
不再需要 $scope.apply 或 $scope.digest，每样东西都透明地工作。或许我们不必推论出 zones 适用于大多数一般场景，但是可以通过使用 VmTurnZone 在 Angular zone 外运行代码。


*** Web Component 
Web Components 是 web 的未来，Angular 2 一开始就打算跟未来的的 web component 库良好协作。 为此，Angular 2 模板语法的一个目标就是保持特性定义简洁，不将任何 Angular 表达式置于其中 —— 一切都通过属性绑定。
为了理解为什么这个很重要，来看下面的例子：
#+begin_src javascript
<ng1-component>
     <web-component-widget setting="{{angularExpresssion}}"></web-component-widget> 
</ng1-component>
#+end_src

*** 依赖注入
感觉 angular2 的依赖注入是学 java 的spring的，DI 在 java 里面还是挺好用的，但是搬到 Javascript 里面有没有必要我是保留意见的。
angular2 的依赖注入可以参考这篇文章   \\
http://gabriel0402.github.io/2015/12/25/angular-dependency-injection/

** Hacker News

*** Index Page

ionic 封装了一个 component 叫做 page， 使用装饰器 @Page 可以轻松创建一个页面，templateUrl 指定一个 html template， 是用 webpack 加载的，十分方便，不用担心再次请求一个文件。

#+begin_src typescript
import {Page, Icon, NavController, Storage, LocalStorage, Hostlistener} from 'ionic';
import {Http, HTTP_PROVIDERS} from 'angular2/http';
import  * as _  from 'lodash';

import {timeDifference} from '../../util'

import {ButtonSequence} from '../../components/buttonSequence/buttonSequence';
import {WaveDirective} from '../../Directives/wave/wave';
//import {ChooseDirective} from '../../Directives/choose/choose';

import {StarPage} from '../star/star';

import 'rxjs/add/operator/map';

import './index.scss';
import './choose.scss';
import './common.scss';

const INIT_ITEM_N = 10;
const fetchNewMins = 5;

let fetchNewGap = 5 * 60 * 1000;

const apis = {
    'new': 'https://hacker-news.firebaseio.com/v0/topstories.json',
    top: 'https://hacker-news.firebaseio.com/v0/newstories.json',
    ask: 'https://hacker-news.firebaseio.com/v0/askstories.json',
    show: 'https://hacker-news.firebaseio.com/v0/showstories.json',
    job: 'https://hacker-news.firebaseio.com/v0/jobstories.json'
}

@Page({
    templateUrl: 'build/pages/index/index.html',
    directives: [Icon, ButtonSequence, WaveDirective]
})
export class IndexPage {
    constructor(nav: NavController, http: Http) {
        this.nav = nav;
        this.http = http;

        this.opItem = null;

        this.bsClicked = false;

        this.local = new Storage(LocalStorage);

        this.category = this.local.get('category')._result || 'new';
        this.items = [];

        this.renderItemList(this.category);

        this.vButtons = [{
            icon: 'md-barcode',
            txt: 'new'
        }, {
            icon: 'md-analytics',
            txt: 'top'
        }, {
            icon: 'md-bulb',
            txt: 'ask'
        }, {
            icon: 'logo-linkedin',
            txt: 'job'
        }, {
            icon: 'md-easel',
            txt: 'show'
        }];

        this.vButtons.map((button) => {
            button.fn = () => {
                this.setCategory(button.txt);
            };
        });

        this.hButtons = [{
            icon: 'moon',
            txt: 'moon',
            fn:  (event) => {
                if (this.hButtons[0].icon === 'moon') {
                    this.hButtons[0].icon = 'md-sunny';
                    this.hButtons[0].txt = 'sun';
                } else {
                    this.hButtons[0].icon = 'moon';
                    this.hButtons[0].txt = 'moon';
                }
            }
        }]
    }

    /*
     *
     * Event
     *
     */
    doRefresh(refresher) {
        this.fetchItemsList(this.category, () => { refresher.complete(); });
    }

    contentClick($event, bs) {
        $event.preventDefault();
        $event.stopPropagation();
            if (this.bsClicked) {
                bs.toggle($event);
            }
    }

    openUrl($event, url) {
        $event.preventDefault();
        $event.stopPropagation();
        window.open(url, '_blank', 'location=yes');
    }

    starItem($event, id) {
        $event.preventDefault();
        $event.stopPropagation();
        let starList = JSON.parse(this.local.get('star_list')._result) || [];

        starList.push(JSON.stringify({
            date: new Date(),
            itemId: id
        }));
        this.local.set('star_list', JSON.stringify(starList));
    }

    closeChoose(clicked) {
        if(!clicked)  {
            return;
        }
        let lastItem = this.opItem;
        if (!!lastItem || lastItem === 0) {
            this.items[lastItem].chooseMove = false;

            setTimeout(() => {
                this.items[lastItem].opChoose = false;
            }, 100);
        }
    }

    cardClick(item, i) {
        let lastItem = this.opItem;
        this.opItem = i;

        if ((!!lastItem || lastItem === 0) && lastItem !== i) {
            this.items[lastItem].chooseMove = false;

            setTimeout(() => {
                this.items[lastItem].opChoose = false;
            }, 100);
        }

        if (item.opChoose) {
            item.chooseMove = false;

            setTimeout(() => {
                item.opChoose = false;
            }, 100);
        } else {
            console.log('not')
            item.opChoose = true;

            setTimeout(() => {
                item.chooseMove = true;
            }, 100);
        }
    }

    goStar($event, bs) {
        if (this.bsClicked) {
                bs.toggle($event);
        }
        this.nav.push(StarPage);
    }

    /*
     *
     * Func
     *
     */

    calcTimeDistance(time) {
        return timeDifference(new Date().getTime(), time * 1000);
    }

    /*
     *
     * LocalStorge
     *
     */

    setCategory(cate) {
        console.log(cate);p
        this.category = cate;
        this.local.set('category', cate);
    }

    setCateList(cate, list) {
        this.local.set('list_' + cate, list);
    }

    getItem(id) {
        return this.local.get('id_' + id)._result;
    }

    setItem(id, data) {
        this.local.set('id_' + id, data);
    }

    /*
     *
     * Network
     *
     */

    fetchItemsList(cate, cb) {

        this.http.get(apis[cate])
        .map(res => res.json())
        .subscribe(
            data => {
                this.setCateList(cate, JSON.stringify(data));
                this.handleItemList(data, cate);
                cb && cb();
            },
            err => this.logError(err)
        );
    }

    refresh() {

    }

    renderItemList(cate) {
        let list = JSON.parse(this.local.get('list_' + cate)._result);

        if (!list) {
            console.log('fetch')
            this.fetchItemsList(cate);
        } else {
            console.log(list);
            this.handleItemList(list);
        }
    }

    handleItemList(data) {
        _.take(data, INIT_ITEM_N).map((itemId) => {
            this.handleItem(itemId);
        })
    }

    handleItem(id) {
        let lItem = this.getItem(id);

        if (lItem) {
            this.items.push(JSON.parse(lItem));
        } else {
            this.http.get(`https://hacker-news.firebaseio.com/v0/item/${id}.json`)
                .map(res => JSON.parse(res.text()))
                .subscribe(
                    itemData => {
                        this.setItem(id, JSON.stringify(itemData));
                        this.items.push(itemData);
                    },
                    err => this.logError(err)
                );
        }
    }

    loadMore() {

    }

    // TODO
    logError(error) {
    }
}

#+end_src

上面的代码中，创建了一个 index 视图，从 hacker news 提供的 api 中获取新闻列表，这个我已经封装了一个 service，但是上面的也就留着吧。


*** 视图
取回来之后计算一些时间距离，渲染了一个列表，点开列表，有两个高亮的按钮，可以选择打开欣慰列表和收藏， 收藏的话，就存入 localstorage 中。

file: index.html

#+begin_src html
<ion-navbar hack *navbar>
    <ion-title>Hack News</ion-title>

    <ion-buttons end>
    <button (click)="goStar($event, bs)">
        <ion-icon [name]="'md-star'"></ion-icon>
    </button>
  </ion-buttons>
</ion-navbar>

<button-sequence #bs [vButtons]="vButtons" [hButtons]="hButtons" (clicked)="bsClicked = !bsClicked; closeChoose(bsClicked)"></button-sequence>


<ion-content (click)="contentClick($event, bs)">

  <ion-refresher (refresh)="doRefresh($event)">
    <ion-refresher-content>
    </ion-refresher-content>
  </ion-refresher>


    
    <ion-card wave *ngFor="#item of items; #i = index" class="item-card" (click)="cardClick(item, i)">

        <ion-card-content>
            <p>{{ item.title }}</p>
        </ion-card-content>

        <ion-item>
            <p>{{ item.by }}</p>
            <p *ngIf="item.text">{{ item.text }}</p>
            <p>{{ calcTimeDistance(item.time) }}</p>
        </ion-item>
        
        <div *ngIf="item.opChoose" class="choose-container" [ngClass]="{move: item.chooseMove}">
            <div class="choose-button star" (click)="starItem($event, item.id)">
                <ion-icon [name]="'md-star'"></ion-icon>
            </div>

            <div class="choose-button open" (click)="openUrl($event, item.url)">
                <ion-icon [name]="'md-compass'"></ion-icon>
            </div>
        </div>
        
    </ion-card>


</ion-content>
#+end_src

*** component
angular2 的 component 的模式的好处在于，一般都会把 scss， html， js 三个文件放在同一个文件夹，改动起来十分方便。

index.html 定义了旁边的一系列按钮，不用的时候收缩成一个，可以选择新闻的类型，这些按钮定义成了一个组件

/file: button-squence.js/
#+begin_src typescript
import {Component, Input, Output, ElementRef, EventEmitter, Hostlistener} from 'angular2/core';
import {Icon, Animation} from 'ionic';

import './buttonSequence.scss'

const buttonSize = 60;
const buttonGap = 30;
const buttonHideOpacity = 0.5;
//const marginToCorner = 30;

@Component({
    selector: 'button-sequence',
    template: `
    <div>
        <div class="sequence-button" (click)="toggle($event)">
            <ion-icon name="md-add"></ion-icon>
        </div>
        <div  class="buttons-container">
        <div *ngFor="#button of vButtons" [ngStyle]="{bottom: button.bottom, opacity: button.opacity}"
               (click)="buttonClick(button.fn, $event)" class="sequence-button v">
               <ion-icon [name]="button.icon"></ion-icon>
        <span class="button-txt" *ngIf="showButtons">{{ button.txt }}</span>
            </div>
      
        <div *ngFor="#button of hButtons" [ngStyle]="{right: button.right, opacity: button.opacity}"
               (click)="buttonClick(button.fn, $event)" class="sequence-button h">
               <ion-icon [name]="button.icon"></ion-icon>
        <span class="button-txt" *ngIf="showButtons">{{ button.txt }}</span>
            </div>

    </div>`,
    host: {
        'class': 'button-sequence'
    },
    directives: [Icon]
})
export class ButtonSequence {
    // 水平 buttons
    private showButtons:bolean = false;
    
    @Input() hButtons: Array<{
        icon: string,
        txt: string,
        fn: any
    }> = [];
    // 垂直 buttons
    @Input() vButtons: Array<{
        icon: string,
        txt: string,
        fn: any
    }> = [];

    @Output() clicked = new EventEmitter();
    
    constructor(private elementRef :ElementRef) {

        this.vButtons.map((button) => {
            button.opacity = buttonHideOpacity;
        });
        this.hButtons.map((button) => {
            button.opacity = buttonHideOpacity;
        });
    }

    buttonClick(fn, e) {
        fn(e);
        this.toggle(e);
    }


    public toggle(event) {
        console.log('toggle');
        
        event.preventDefault();
        event.stopPropagation();
        
        this.showButtons = !this.showButtons;

        this.clicked.emit(this.showButtons);
        
        if( this.showButtons ){
            let b = 0;
            this.vButtons.map((button) => {
                b = buttonGap + buttonSize + b;
                button.bottom = b + 'px';
                button.opacity = 1;
            });

            b = 0;
            this.hButtons.map((button) => {
                b = buttonGap + buttonSize + b;
                button.right = b + 'px';
                button.opacity = 1;
            });
            
        } else {
            this.vButtons.map((button) => {
                button.bottom = null;
                button.opacity = buttonHideOpacity;
            });

            this.hButtons.map((button) => {
                button.right = null;
                button.opacity = buttonHideOpacity;
            });
        }



    }
    
}

#+end_src

/file: button.js/
#+begin_src typescript
import {Component, Input, HostListener, ElementRef} from 'angular2/core';
import {Icon, Animation} from 'ionic/ionic';

import './buttonSequence.scss'

@Component({
    selector: 'sequence-button',
    template: `
        <div class="sequence-button">
            <ion-icon [name]="content.icon"></ion-icon>
        </div>`,
    host: {
        'class': 'button-sequence'
    },
    directives: [Icon],
    host: {
        style: 'content.style'
    }
})
export class SequenceButton {
    // 水平 buttons
    @Input() content;

    
    constructor(private _elementRef: ElementRef) {
        
    }

    public click(elem) {

        
        
    }
    
}

#+end_src

*** 收藏页面

ionic2 默认的路由策略不是通过 url，是直接操作 dom，这个好像在调试的时候会麻烦一些，下面定义收藏页面

/file: star.html/
#+begin_src typescript
import {Page, Icon, NavController, Storage, LocalStorage, Hostlistener} from 'ionic';

import {HacknewApi} from '../../service/hacknew-api/hacknew-api'
import {CONFIG} from '../../config.js';


@Page({
    templateUrl: 'build/pages/star/star.html',
    directives: [Icon],
    providers: [HacknewApi]
})
export class StarPage {
    constructor(nav: NavController, hack: HacknewApi) {
        this.items = [];
        this.local = new Storage(LocalStorage);
        this.hackapi = hack;

        this.refresh();
    }

    refresh() {
        let starList = JSON.parse(this.local.get('star_list')._result);
        console.log(starList);
        starList.map((starItem) => {
            let starItem = JSON.parse(starItem);
            this.hackapi.getItem(starItem.itemId, (data) => {
                this.renderItem(starItem.date, data);
            });
            
        });
    }

    renderItem(date, item) {
        console.log(item);
        this.items.push(item);
    }

    cardClick() {
        
    }
}

#+end_src


#+begin_src html
<ion-navbar hack *navbar>
    <ion-title>Star</ion-title>
</ion-navbar>

<ion-content>

  <ion-card wave *ngFor="#item of items; #i = index" class="item-card" (click)="cardClick(item, i)">

    <ion-card-content>
      <p>{{ item.title }}</p>
    </ion-card-content>

    <ion-item>
      <p>{{ item.by }}</p>
      <p *ngIf="item.text">{{ item.text }}</p>
    </ion-item>
    
    <div *ngIf="item.opChoose" class="choose-container" [ngClass]="{move: item.chooseMove}">
      <div class="choose-button star" (click)="openUrl($event, item.url)">
        <ion-icon [name]="'md-star'"></ion-icon>
      </div>

      <div class="choose-button open" (click)="starItem($event, item.id)">
        <ion-icon [name]="'md-compass'"></ion-icon>
      </div>
    </div>
    
  </ion-card>
    
</ion-content>




#+end_src

*** 指令
angular2 的指令思想和 angular1 差的不是很多，都是操作 dom 的地方， 把 dom 和逻辑层隔开。
虽然形式上有很大的不一样, 例如注入函数变成了构造器形式，element 也封装成了一系列装饰器了

/file choose.js/
#+begin_src javascript
wimport {Directive, ElementRef, Input, HostListener} from 'angular2/core';

import './choose.scss';

//const headerHeight = 44;

@Directive({
    selector: '[card-choose]'
})
export class ChooseDirective {
    
    constructor(private el: ElementRef) {
        // el.nativeElement.style.backgroundColor = 'yellow';
        this.buttons = [{
            icon: 'md-star',
            txt: 'Star',
            fn: ($event) => {
                console.log('star');
            }
        },{
            icon: 'md-star',
            txt: 'Star2',
            fn: ($event) => {
                console.log('star2');
            }
        }]
    }

    @HostListener('click', ['$event'])
    public onClick($event) {
        $event.preventDefault();

        /* let offsetX = $event.pageY - this.el.nativeElement.offsetTop + this.el.nativeElement.parentNode.scrollTop - headerHeight,
           offsetY = $event.pageX - this.el.nativeElement.offsetLeft - 25; */

        let cardHeight = this.el.nativeElement.clientHeight,
            cardWidth = this.el.nativeElement.clientWidth;

        let centerX = cardWidth / 2,
            centerY = cardHeight / 2;

        console.log($event);
        console.log(this.el);

        let container = document.createElement('div');

        container.classList.add('card-choose-container');
        container.style.top = centerX + 'px';
        container.style.left = centerY + 'px';

        this.buttons.map((button) => {
            let ct = document.createElement('div');
            ct.classList.add('choose-button');

            //let icon = document.

        });

        this.el.nativeElement.appendChild(container);
        
        
    }
    
    
}
#+end_src

/file wave.js/
#+begin_src javascript
import {Directive, ElementRef, Input, HostListener} from 'angular2/core';

import './wave.scss';

@Directive({
    selector: '[wave]',
    host: {
        'class': 'wave-ripple'
    }
})
export class WaveDirective {
    
    constructor(private el: ElementRef) {
        // el.nativeElement.style.backgroundColor = 'yellow';
    }

    @HostListener('click', ['$event'])
    public onClick($event) {
        $event.preventDefault();
        let elHeight = this.el.nativeElement.clientHeight,
        elWidth = this.el.nativeElement.clientWidth;
        // console.log(this.el.nativeElement.parentNode.scrollTop);
        // console.log($event.y);
        // console.log(this.el.nativeElement.offsetTop);
        let ripple = document.createElement('div');
        ripple.classList.add('wave-ripple-effect');

        // 还要减去 content 的 scrollTop 的值
        ripple.style.top = ($event.pageY - this.el.nativeElement.offsetTop + this.el.nativeElement.parentNode.scrollTop - 44 - 25 ) + 'px'; // 44 为头部的高度
        ripple.style.left = ($event.pageX - this.el.nativeElement.offsetLeft - 25) + 'px';
        
        this.el.nativeElement.appendChild(ripple);

        setTimeout(() => {
            this.el.nativeElement.removeChild(ripple);
        }, 2000)

        // console.log(this.el)
        //console.log($event);
    }
    
    
}
#+end_src


