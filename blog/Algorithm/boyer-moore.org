#+TITLE: Boyer Moore 算法
#+AUTHOR: 陳放為

#+BEGIN_HTML
<style>
th, td
{
border: 1px solid black;
}
td {
width: 1em;
}
</style>
#+END_HTML

最近因为项目需要，要用到 boyer-moore 算法, 看了阮一峰的老师的博客，感觉语言有点生硬，像是翻译的文章，有些地方说得不够清楚，特别是好后缀的部分，于是有了下面这样的一篇博客， 写得也不是很好，让大家见笑了。

** 源码
首先上全部的代码, es6 写的，没有外部依赖

#+BEGIN_SRC javascript
'use strict';

let isPrefix = (pattern, i, len) => {
    let start = 0;
    for(let j = i; j < len; ++start, ++j) {
        if( pattern[j] !== pattern[start] ){
            return false;
        }
    }
    return true;
};

let getSuffixLength = (pattern, i, len) => {
    let j = 0,
        start = i;
    for(let end = len - 1; start >= 0 && pattern[start] === pattern[end]; --start, --end) {
        j++;
    }
    return j;
};

let makeBadRule = (pattern) => {
    let n = pattern.length,
        rule = new Array(n - 1);
    for (let i = 0; i < n - 1; ++i) {
        rule[i] = {};
        for (let j = 0; j < n - i - 1; ++j) {
            rule[i][pattern[j]] = n - i - j - 1;
        }
    }
    return rule;
};

let makeGoodSuffixTable = (pattern) => {
    let len = pattern.length,
        goodSuffixArray = new Array(len),
        lastPrefixSuffixIndex = len;
    
    for(let j = len - 2; j >= 0; --j) {
        if( isPrefix(pattern, j + 1, len) ){
            lastPrefixSuffixIndex = len - (len - j - 1);

        }
        goodSuffixArray[len - j - 1] = lastPrefixSuffixIndex;
    }
    for (let j = 0; j < len - 1; ++j) {
        let suffixLength = getSuffixLength(pattern, j, len);
        for (let k = suffixLength; k > 0; --k) {
            goodSuffixArray[k] = len - suffixLength + 1 - j;
        }
    }
    return goodSuffixArray;
};

export class BoyerMooreCount {
    constructor(pattern) {
        this.badRule = makeBadRule(pattern),
        this.goodSuffixTable = makeGoodSuffixTable(pattern);
        this.pattern = pattern;
    }

    indexFor(string) {
        let n = this.pattern.length;
        for(let i = n - 1, max = string.length; i < max;) {
            let k = n - 1;
            for (; this.pattern[k] === string[i]; --i, --k) {
                if( k === 0 ){
                    return i;
                }
            }
            let bad = this.badRule[n - k - 1][string[i]] || n;
            let good = this.goodSuffixTable[n - k - 1] || 1;
            i += Math.max(bad, good);
        }
        return -1;
    }
}
#+END_SRC

** 坏字符

坏字符很好理解，用下面的例子来讲解：

| H | E | R | E |   | I | S |  | A |  | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
| E | X | A | M | P | L | E |  |   |  |   |   |   |   |   |   |   |   |   |   |   |   |   |   |

第一行为待查找的字符串，第二行的 EXAMPLE 为查找的目标字符串。
坏字符规则先从后面开始比较，就是 EXAMPLE 的最后一个字母 E，E 和上面的对齐的 S 不一样，这样可以肯定的是，上面与 EXAMPLE 对齐的字符都不匹配，这个很好理解，所以 EXAMPLE 可以直接右移自身的位数。

| H | E | R | E |   | I | S |   | A |   | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
|   |   |   |   |   |   |   | E | X | A | M | P | L | E |   |   |   |   |   |   |   |   |   |   |

再次从最后面开始比较，E 和 P 也不同，但是这次与上面的例子不同的是，上面的 P 存在与下周的目标字符串中，那么就代表着有下面带比较的 P 移动到最后面的 E 的位置时，字符串是匹配成功的，有可能的话就不能漏过，所以我们将待比较的字符串右移两位。

| H | E | R | E |   | I | S |   | A |   | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
|   |   |   |   |   |   |   |   |   | E | X | A | M | P | L | E |   |   |   |   |   |   |   |   |

再次从最后比较，E 相同，然后比较前一位 L，相同，再比较 P，最后比较到 A，噢，不同，A 对应上面的 I 不存在与目标字符串中，那么直接右移自身位数。

| H | E | R | E |   | I | S |   | A |   | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | E | X | A | M | P | L | E |   |

比较 E 和 L， L 存在与下面 E 的前一位，所以右移一位

| H | E | R | E |   | I | S |   | A |   | S | I | M | P | L | E |   | E | X | A | M | P | L | E |
|   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | E | X | A | M | P | L | E |

从最后一直比较上去，噢耶，都匹配，所以这个目标字符串存在于待比较字符串中，匹配成功，这就是坏字符规则。

我们可以终结出规律：

后移位数 = 坏字符的位置 - 搜索词中的正在比较的位置前面出现偏移量

牛逼的是，这个规律是与待比较字符串无关的，所以我们可以先生成一张坏字符规律的表。
代码是这段。
#+BEGIN_SRC javascript 
let makeBadRule = (pattern) => { // pattern 是目标字符串
    let n = pattern.length,
        rule = new Array(n - 1);
    for (let i = 0; i < n - 1; ++i) {
        rule[i] = {};
        for (let j = 0; j < n - i - 1; ++j) {
            rule[i][pattern[j]] = n - i - j - 1;
        }
    }
    return rule;
};
#+END_SRC

这里我生成的是多维数组，从最后的位数开始，填入如果待比较字符串对应的字符出现在这个位置的右移位数。

有很多算法是直接生成一维数组，从最后开始生成，填入目标字符串的字符如果出现待比较字符串中比较时，右移的位数，


| E | X | A | M | P | E | L | 
